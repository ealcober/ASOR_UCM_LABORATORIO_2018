
Ejercicio 1. La herramienta principal para consultar el contenido y atributos básicos de un fichero es ls. Consultar la página de manual y estudiar el uso de las opciones -a -l -d -h -i -R -1 -F y --color. Estudiar el significado de la salida en cada caso.

-a     Incluye ficheros cuyos nombres empiecen por `.'.
-d     Lista nombres de directorios como  otros  ficheros,  en  vez  de listar sus contenidos.
-l     Escribe (en formato  de  una  sola  columna)  los  permisos  del
       fichero,   el  número  de  enlaces  que  tiene,  el  nombre  del
       propietario, el del  grupo  al  que  pertenece,  el  tamaño  (en
       bytes),  una marca de tiempo, y el nombre del fichero.  De forma
       predeterminada, la marca de tiempo que se muestra es  la  de  la
       última  modificación.
-h, --human-readable
       Añade una letra indicativa de tamaño, tal como M para  megabytes.
-i, --inode
       Muestra el número de nodo-í.
-F, --classify, --indicator-style=classify
       Añade un carácter a cada nombre de fichero indicando el tipo del
       fichero.  Para ficheros regulares que sean ejecutables, añade un
       `*'.  Los  indicadores  de  tipos  de  ficheros  son  `/'   para
       directorios,  `@'  para  enlaces simbólicos, `|' para FIFOs, `='
       para conectores, y nada para ficheros regulares.
-R, --recursive
       Lista los contenidos de todos los directorios recursivamente.
--color[=cuándo]
       Especifica  si  emplear color para distinguir tipos de ficheros.
       Los colores se  especifican  mediante  la  variable  de  entorno
       LS_COLORS.   Para   información  acerca  de  cómo  definir  esta
       variable, consulte dircolors(1).  cuándo puede omitirse,  o  ser
       uno de:
       		none   No emplear color en absoluto. Esto es lo predeterminado.
       		auto   Emplear  color  solamente  si  la  salida estándar es una
       		       terminal.
       		always Emplear color siempre. Especificar --color y no cuándo es
       		       equivalente a --color=always.
-1, --format=single-column
       Lista un fichero por línea. Esto es lo predeterminadao cuando la
       salida estándar no es una terminal.


Ejercicio 2. Los permisos de un fichero son <tipo><rwx_propietario><rwx_grupo><rwx_resto>:
* tipo: - fichero; d directorio; l enlace; c dispositivo carácter; b dispositivo bloque; p FIFO; s socket
* r: lectura (4); w: escritura (2); x: ejecución (1)
Comprobar los permisos de algunos directorios (con ls -ld).

ealcober@debian:~$ pwd
/home/ealcober
ealcober@debian:~$ ls -ld
drwxr-xr-x 46 ealcober ealcober 4096 nov  4 13:17 .
ealcober@debian:~$ cd ..
ealcober@debian:/home$ ls -ld
drwxr-xr-x 3 root root 4096 sep  1 21:45 .
ealcober@debian:/home$ cd ..
ealcober@debian:/$ ls -ld
drwxr-xr-x 23 root root 4096 sep  1 22:00 .

Ejercicio 3. Los permisos se pueden otorgar de forma selectiva usando la notación octal o la simbólica. Ejemplo, probar las siguientes órdenes (equivalentes):
* chmod 540 mi_echo.sh
* chmod u+rx,g+r-wx,o-wxr mi_echo.sh
¿Cómo se podrían fijar los permisos rw-r--r-x, de las dos formas?

ealcober@debian:~/test$ ls -la
total 8
drwxr-xr-x  2 ealcober ealcober 4096 nov  4 21:23 .
drwxr-xr-x 47 ealcober ealcober 4096 nov  4 21:23 ..
-rw-r-xr-x  1 ealcober ealcober    0 nov  4 21:23 mi_echo.sh
ealcober@debian:~/test$ chmod g-x mi_echo.sh 
ealcober@debian:~/test$ ls -la
total 8
drwxr-xr-x  2 ealcober ealcober 4096 nov  4 21:23 .
drwxr-xr-x 47 ealcober ealcober 4096 nov  4 21:23 ..
-rw-r--r-x  1 ealcober ealcober    0 nov  4 21:23 mi_echo.sh
ealcober@debian:~/test$ chmod u+rwx,g+rwx,o+rwx mi_echo.sh 
ealcober@debian:~/test$ ls -la
total 8
drwxr-xr-x  2 ealcober ealcober 4096 nov  4 21:23 .
drwxr-xr-x 47 ealcober ealcober 4096 nov  4 21:23 ..
-rwxrwxrwx  1 ealcober ealcober    0 nov  4 21:23 mi_echo.sh
ealcober@debian:~/test$ chmod 645 mi_echo.sh 
ealcober@debian:~/test$ ls -la
total 8
drwxr-xr-x  2 ealcober ealcober 4096 nov  4 21:23 .
drwxr-xr-x 47 ealcober ealcober 4096 nov  4 21:23 ..
-rw-r--r-x  1 ealcober ealcober    0 nov  4 21:23 mi_echo.sh



Ejercicio 4. Crear un directorio y quitar los permisos de ejecución para usuario, grupo y otros. Intentar cambiar al directorio.

ealcober@debian:~/test$ mkdir ohno
ealcober@debian:~/test$ chmod u-x,g-x,o-x ohno/
ealcober@debian:~/test$ ls -la ohno/
ls: no se puede acceder a 'ohno/.': Permiso denegado
ls: no se puede acceder a 'ohno/..': Permiso denegado
total 0
d????????? ? ? ? ?            ? .
d????????? ? ? ? ?            ? ..
ealcober@debian:~/test$ cd ohno/
bash: cd: ohno/: Permiso denegado


Ejercicio 5. Escribir un programa que, usando la llamada open, cree un fichero con los permisos rw-r--r-x. Comprobar el resultado y las características del fichero con la orden ls.

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>



/*
Escribir un programa que, usando la llamada open, cree un fichero con los permisos rw-r--r-x. (645)
*/
int main(int argc, char *argv[])
{
    // argv[0] nombre programa
    // argv[1] nombre fichero a crear
    int f1 = open(argv[1], O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH | S_IXOTH);

    if (f1 == -1)
    {
        perror("error en la creación del fichero: ¿Ya existe?");
        return 1;
    }
    else
    {
        close(f1);
        return 0;

    }


}

ealcober@debian:~/test/src$ gcc -o ej5 ej5.c 
ealcober@debian:~/test/src$ ./ej5 fichero_test
ealcober@debian:~/test/src$ ls
argv[1]  ej5  ej5.c  fichero_test
ealcober@debian:~/test/src$ ls -la
total 24
drwxr-xr-x 2 ealcober ealcober 4096 nov  4 21:39 .
drwxr-xr-x 4 ealcober ealcober 4096 nov  4 21:27 ..
-rw-r--r-x 1 ealcober ealcober    0 nov  4 21:39 argv[1]
-rwxr-xr-x 1 ealcober ealcober 8744 nov  4 21:39 ej5
-rw-r--r-- 1 ealcober ealcober  547 nov  4 21:39 ej5.c
-rw-r--r-x 1 ealcober ealcober    0 nov  4 21:39 fichero_test
ealcober@debian:~/test/src$

Ejercicio 6. Cuando se crea un fichero, los permisos por defecto se derivan de la máscara de usuario (umask). El comando umask permite consultar y fijar esta máscara. Usando este comando, fijar la máscara de forma que los nuevos ficheros no tengan permiso de escritura para el grupo y ningún permiso para otros. Comprobar el funcionamiento con los comandos touch y ls.

¡la máscara es "LO QUE LE QUITAMOS"!

usuario_vms@pto0503:~$ umask 027
usuario_vms@pto0503:~$ touch acme
usuario_vms@pto0503:~$ ls -la acme
-rw-r----- 1 usuario_vms users 0 nov  5 09:17 acme
 000010111

Ejercicio 7. Modificar el ejercicio 5 para que, antes de crear el fichero, se fije la máscara igual que en el ejercicio anterior. Una vez creado el fichero, debe restaurarse la máscara original del proceso. Comprobar el resultado con el comando ls.

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>



/*
Escribir un programa que, usando la llamada open, cree un fichero con los permisos rw-r--r-x. (645)
*/
int main(int argc, char *argv[])
{
    // argv[0] nombre programa
    // argv[1] nombre fichero a crear
    umask(027);
    int f1 = open(argv[1], O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH | S_IXOTH);

    if (f1 == -1)
    {
        perror("error en la creación del fichero: ¿Ya existe?");
        umask(022);
        return 1;
    }
    else
    {
        close(f1);
        umask(022);
        return 0;

    }


}

usuario_vms@pto0503:~/p22_ealcober$ ./ej7 acme
usuario_vms@pto0503:~/p22_ealcober$ touch acme2
usuario_vms@pto0503:~/p22_ealcober$ ls -la acme*
-rw-r--r-x 1 usuario_vms users 0 nov  5 09:23 acme
-rw-r--r-- 1 usuario_vms users 0 nov  5 09:23 acme2


Ejercicio 8. El comando ls puede mostrar el inodo con la opción -i. El resto de información del inodo puede obtenerse usando el comando stat. Consultar las opciones del comando y comprobar su funcionamiento.

usuario_vms@pto0503:~/p22_ealcober$ stat --terse acme
acme 0 0 81a5 565 100 805 7120283 1 0 0 1541406234 1541406234 1541406234 0 4096
usuario_vms@pto0503:~/p22_ealcober$ stat -L palomitas 
  Fichero: palomitas
  Tamaño: 0           Bloques: 0          Bloque E/S: 4096   fichero regular vacío
Dispositivo: 805h/2053d Nodo-i: 7120283     Enlaces: 1
Acceso: (0645/-rw-r--r-x)  Uid: (  565/usuario_vms)   Gid: (  100/   users)
Acceso: 2018-11-05 09:23:54.887241771 +0100
Modificación: 2018-11-05 09:23:54.723241774 +0100
      Cambio: 2018-11-05 09:23:54.723241774 +0100
    Creación: -
usuario_vms@pto0503:~/p22_ealcober$ stat palomitas 
  Fichero: palomitas -> acme
  Tamaño: 4           Bloques: 0          Bloque E/S: 4096   enlace simbólico
Dispositivo: 805h/2053d Nodo-i: 7120285     Enlaces: 1
Acceso: (0777/lrwxrwxrwx)  Uid: (  565/usuario_vms)   Gid: (  100/   users)
Acceso: 2018-11-05 09:27:42.255236823 +0100
Modificación: 2018-11-05 09:27:42.243236823 +0100
      Cambio: 2018-11-05 09:27:42.243236823 +0100
    Creación: -


Ejercicio 9. Escribir un programa que emule el comportamiento del comando stat y muestre:
* El número major y minor asociado al dispositivo
* El número de inodo del archivo
* El tipo de archivo (directorio, enlace simbólico o archivo ordinario)
* La hora en la que se accedió el fichero por última vez. ¿Qué diferencia hay entre st_mtime y st_ctime?

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/sysmacros.h>
#include <time.h>



/*
int stat(const char *pathname, struct stat *statbuf);

struct stat {
               dev_t     st_dev;         /* ID of device containing file 
               ino_t     st_ino;         /* Inode number 
               mode_t    st_mode;        /* File type and mode 
               nlink_t   st_nlink;       /* Number of hard links 
               uid_t     st_uid;         /* User ID of owner 
               gid_t     st_gid;         /* Group ID of owner 
               dev_t     st_rdev;        /* Device ID (if special file) 
               off_t     st_size;        /* Total size, in bytes 
               blksize_t st_blksize;     /* Block size for filesystem I/O 
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated 

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. 

               struct timespec st_atim;  /* Time of last access 
               struct timespec st_mtim;  /* Time of last modification
               struct timespec st_ctim;  /* Time of last status change 

           #define st_atime st_atim.tv_sec      /* Backward compatibility 
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           
*/

int main(int argc, char* argv[]){
  
  struct stat info;
  stat(argv[1], &info);

  struct tm* tm_info;
  struct tm* tm_info2;

  char buffer[26];

  tm_info = localtime(&info.st_mtim.tv_sec);
  tm_info2 = localtime(&info.st_ctim.tv_sec);

  /*
* El número major y minor asociado al dispositivo
* El número de inodo del archivo
* El tipo de archivo (directorio, enlace simbólico o archivo ordinario)
* La hora en la que se accedió el fichero por última vez. ¿Qué diferencia hay entre st_mtime y st_ctime?
  */
  // con info.st_dev y las macros minor y major podemos sacar estos números
  printf("ID of device containing file: %lu\n", info.st_dev);
  printf("Major Number: %d\n", major(info.st_dev));
  printf("Minor Number: %d\n", minor(info.st_dev));
  printf("Inode number: %lu\n", info.st_ino);
  printf("File type and mode: %u\n", info.st_mode);
  /*printf("Number of hard links: %lu\n", info.st_nlink);
  printf("User ID of owner: %d\n", info.st_uid);
  printf("Group ID of owner: %d\n", info.st_gid);
  printf("Device ID (if special file): %lu\n", info.st_rdev);
  printf("Total size, in bytes: %li\n", info.st_size);
  printf("Block size for filesystem I/O: %li\n", info.st_blksize);
  printf("Number of 512B blocks allocated  %li\n", info.st_blocks); 
  */

/*
struct timespec {
    time_t   tv_sec;   //      seconds 
    long     tv_nsec;  //      nanoseconds 
}
*/
    // printf("%lld.%.9ld", (long long)ts.tv_sec, ts.tv_nsec)
  printf("Time of last modification:");
    strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info);
    puts(buffer);
    printf("Time of last status change:");
    strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info2);
    puts(buffer);

  //printf("Time of last modification: %lld.%.9ld\n", (long long)info.st_mtim.tv_sec, info.st_mtim.tv_nsec);  // Time of last modification
  //printf("Time of last status change: %lld.%.9ld\n", (long long)info.st_ctim.tv_sec, info.st_ctim.tv_nsec);  // Time of last status change

  return 0;

}


// ej 10 omitido. es de enlaces simbólicos y rígidos.

Ejercicio 11. Las llamadas link y symlink crean enlaces rígidos y simbólicos respectivamente. Escribir un programa que reciba una ruta a un fichero como argumento. Si la ruta es un fichero regular crear un enlace simbólico y rígido (con el mismo nombre terminado en .sym y .hard). Comprobar el resultado con la orden ls.

#include <unistd.h>
#include <stdio.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/sysmacros.h>
#include <time.h>


int main(int argc, char* argv[]){

  struct stat info;
  stat(argv[1], &info);
  int longsym = strlen(argv[1])+4;
    int longhard = strlen(argv[1])+5;
  char nombreSym[longsym];
    char nombreHard[longhard];

    nombreSym[0]='\0';
    nombreHard[0]='\0';

    //sprintf(nombreSym, "%s.sym", argv[1]);
    // equivale a strcat(nombreSym, argv[1]);
    //          strcat(nombreSym, ".sym");
    //sprintf(nombreHard, "%s.hard", argv[1]);
    // equivale a strcat(nombreHard, argv[1]);
    //            strcat(nombreHard, ".hard");
  switch(info.st_mode & S_IFMT){
        case S_IFREG:
            printf("Regular File, linking\n");
            
            sprintf(nombreSym, "%s.sym", argv[1]);
            sprintf(nombreHard, "%s.hard", argv[1]);
            
            printf("%s\n",nombreHard);puts("\n");
            printf("%s\n",nombreSym);puts("\n");
            break;
        case S_IFDIR:
            printf("Directory\n");
            break;
        case S_IFBLK:
            printf("Block Device\n");
            break;
        case S_IFCHR:
            printf("Character Device\n");
            break;
        case S_IFSOCK:
            printf("Socket\n");
            break;
        case S_IFLNK:
            printf("Symbolic Link\n");
            break;



}

return 0;
}


Redirecciones y duplicación de descriptores
La shell proporciona operadores (>, >&, >>) que permiten redirigir un fichero a otro, ver los ejercicios propuestos en la práctica opcional. Esta funcionalidad se implementa mediante las llamadas dup y dup2.

Ejercicio 1. Escribir un programa que redirija la salida estándar a un fichero cuya ruta se pasa como primer argumento. Probar haciendo que el programa escriba varias cadenas en la salida estándar.





Ejercicio 2. Modificar el programa anterior para que además de escribir en el fichero la salida estándar también se escriba la salida estándar de error. Comprobar el funcionamiento incluyendo varias sentencias que impriman en ambos flujos. ¿Hay alguna diferencia si las redirecciones se hacen en diferente orden? ¿Por qué no es lo mismo “ls > dirlist 2>&1” que “ls 2>&1 > dirlist”?

Ejercicio 3 (Opcional). La llamada fcntl(2) también permite duplicar descriptores de fichero. Estudiar qué opciones hay que usar para que fcntl duplique los descriptores.

Cerrojos de ficheros
El sistema de ficheros ofrece un sistema de bloqueos consultivo. Estas funciones se pueden acceder mediante flock o fcntl. En esta sección usaremos únicamente fcntl(2).

Ejercicio 1. El estado y cerrojos de fichero en uso en el sistema se pueden consultar en el archivo /proc/locks. Estudiar el contenido de este archivo.

Ejercicio 2. Escribir un programa que consulte y muestre en pantalla el estado del cerrojo sobre un fichero. El programa mostrará el estado del cerrojo (bloqueado, desbloqueado). Además:
* Si está desbloqueado, fijará un cerrojo de escritura y escribirá la hora actual. Después suspenderá su ejecución durante 30 segundos (función sleep) y a continuación liberará el cerrojo.
* Si el cerrojo está bloqueado terminará el programa.
El programa no deberá modificar el contenido del fichero si no tiene el cerrojo.


Ejercicio 3 (Opcional). El comando flock proporciona funcionalidad de cerrojos en guiones shell. Consultar la página de manual y el funcionamiento del comando.
Proyecto: Comando ls extendido
Escribir un programa que cumpla las siguientes especificaciones:
* El programa tiene un único argumento que es la ruta a un directorio. El programa debe comprobar la corrección del argumento.
* El programa recorrerá las entradas del directorio de forma que:
   * Si es un fichero normal, escribirá el nombre.
   * Si es un directorio, escribirá el nombre seguido del carácter ‘/’
   * Si es un enlace simbólico, escribirá el nombre seguido de ‘-><fichero al que apunta>’. Usar la función readlink(2) y dimensionar adecuadamente el buffer de la función.
   * Si el fichero es ejecutable, escribirá el nombre seguido del carácter ‘*’
* Al final de la lista el programa escribirá el tamaño total que ocupan los ficheros (no directorios) en kilobytes.




________________


Ampliación de Sistemas Operativos y Redes